#!/usr/bin/env python3
import asyncio
from grader.tcp import Servidor
import re

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None

def sair(conexao):
    print('> Connection closed')
    conexao.fechar()

def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)

    print('! Data received: "%s"' % dados)

    messages = parseMessages(conexao, dados)

    for message in messages:
        if not len(message): continue

        messageType, messageData = message.split(b' ', 1)

        print('> Processing message. Type: "%s" Data: "%s"' % (messageType, messageData))
        handleMessage(conexao, messageType, messageData)

missingData = {}

def parseMessages(conexao, dados):
    global missingData

    # 'linha\r\n'             -> ('linha', '')
    # 'linha1\r\nlinha2\r\n   -> ('linha1', 'linha2', '')
    # 'a 1\r\nlinha 2\r\nli'  -> ('a 1', 'linha 2', 'li')
    # 'lin' ... 'h' ... 'a\r\n'
    messages = dados.split(b'\r\n')

    remoteAddrs = conexao.s.getpeername()

    # inicializa o dicionario para a conexão atual
   # if not remoteAddrs in missingData:
    #    missingData[remoteAddrs] = b''
    if not conexao in missingData:
      missingData[conexao] = b''

    # verifica se existe dados residuais da conexão atual
    # if not missingData[remoteAddrs] == b'':
    if not missingData[conexao] == b'':
       # messages[0] = missingData[remoteAddrs] + messages[0]
       messages[0] = missingData[conexao] + messages[0]
       # missingData[remoteAddrs] = b''
       missingData[conexao] = b''

    # verifica se existe dados residuais na última mensagem
    if not messages[-1] == b'':
      #  missingData[remoteAddrs] = missingData[remoteAddrs] + messages[-1]
        missingData[conexao] = missingData[conexao] + messages[-1]
        messages[-1] = b''

    # verifica se os dados residuais estão completos
    # if missingData[remoteAddrs].endswith(b'\r\n'):
    if missingData[conexao].endswith(b'\r\n'):
      #  messages.insert(0, missingData[remoteAddrs])
      #  missingData[remoteAddrs] = b''
      messages.insert(0, missingData[conexao])
      missingData[conexao] = b''

    # deleta do dicionario dados residuais vazios
    # if missingData[remoteAddrs] == b'':
    if missingData[conexao] == b'':
        # del missingData[remoteAddrs]
        del missingData[conexao]

    return messages

users = {}

def handleMessage(conexao, messageType, messageData):
    global users

    if messageType == b'PING':
        response = b':server PONG server :%s\r\n' % messageData
        conexao.enviar(response)
        return

    elif messageType == b'NICK':
        if not validar_nome(messageData):
            response = b':server 432 * %s :Erroneous nickname\r\n' % messageData
            conexao.enviar(response)
            return

        remoteAddrs = conexao.s.getpeername()

        # define o apelido_atual
        # oldNick = users[remoteAddrs] if remoteAddrs in users else b'*'
        oldNick = users[conexao] if conexao in users else b'*'

        # verifica se o nick já está sendo usado
        if messageData.lower() in [x.lower() for x in list(users.values())]:
        # if re.search("{messageData}", "{list(users.values())}", re.IGNORECASE) != None:
            response = b':server 433 %s %s :Nickname is already in use\r\n' % (oldNick, messageData)
            conexao.enviar(response)
            return

        # verifica se o usuário já existe
        # if remoteAddrs in users:
        if conexao in users:
            response = b':%s NICK %s\r\n' % (oldNick, messageData)
            conexao.enviar(response)
        else:
            response1 = b':server 001 %s :Welcome\r\n' % messageData
            conexao.enviar(response1)
            response2 = b':server 422 %s :MOTD File is missing\r\n' % messageData
            conexao.enviar(response2)

        # users[remoteAddrs] = messageData
        users[conexao] = messageData
        return
    
    elif messageType == b'PRIVMSG':
      return

    else:
        print('? Message type not implemented: "%s"' % messageType)



def conexao_aceita(conexao):
    print('> New connection')
    conexao.registrar_recebedor(dados_recebidos)


servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)

print('> Servidor started')

asyncio.get_event_loop().run_forever()
