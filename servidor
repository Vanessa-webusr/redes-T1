#!/usr/bin/env python3
import asyncio
from grader.tcp import Servidor
import re

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None

def sair(conexao):
    print('> Connection closed')

    if conexao in missingData:
        del missingData[conexao]

    if conexao in users:
        del users[conexao]

    conexao.fechar()

def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)

    print('! Data received: "%s"' % dados)

    messages = parseMessages(conexao, dados)

    for message in messages:
        if not len(message): continue

        messageType, messageData = message.split(b' ', 1)

        print('> Processing message. Type: "%s" Data: "%s"' % (messageType, messageData))
        handleMessage(conexao, messageType, messageData)

missingData = {}

def parseMessages(conexao, dados):
    global missingData

    # 'linha\r\n'             -> ('linha', '')
    # 'linha1\r\nlinha2\r\n   -> ('linha1', 'linha2', '')
    # 'a 1\r\nlinha 2\r\nli'  -> ('a 1', 'linha 2', 'li')
    # 'lin' ... 'h' ... 'a\r\n'
    messages = dados.split(b'\r\n')

    # inicializa o dicionario para a conexão atual
    if not conexao in missingData:
      missingData[conexao] = b''

    # verifica se existe dados residuais da conexão atual
    if not missingData[conexao] == b'':
       messages[0] = missingData[conexao] + messages[0]
       missingData[conexao] = b''

    # verifica se existe dados residuais na última mensagem
    if not messages[-1] == b'':
        missingData[conexao] = missingData[conexao] + messages[-1]
        messages[-1] = b''

    # verifica se os dados residuais estão completos
    if missingData[conexao].endswith(b'\r\n'):
      messages.insert(0, missingData[conexao])
      missingData[conexao] = b''

    # deleta do dicionario dados residuais vazios
    if missingData[conexao] == b'':
        del missingData[conexao]

    return messages

users = {}

def handleMessage(conexao, messageType, messageData):
    global users

    if messageType == b'PING':
        response = b':server PONG server :%s\r\n' % messageData
        conexao.enviar(response)
        return

    elif messageType == b'NICK':
        if not validar_nome(messageData):
            response = b':server 432 * %s :Erroneous nickname\r\n' % messageData
            conexao.enviar(response)
            return

        # define o apelido_atual
        oldNick = users[conexao] if conexao in users else b'*'

        # verifica se o nick já está sendo usado
        if usingNick(messageData):
        # if re.search("{messageData}", "{list(users.values())}", re.IGNORECASE) != None:
            response = b':server 433 %s %s :Nickname is already in use\r\n' % (oldNick, messageData)
            conexao.enviar(response)
            return

        # verifica se o usuário já existe
        
        if conexao in users:
            response = b':%s NICK %s\r\n' % (oldNick, messageData)
            conexao.enviar(response)
        else:
            response1 = b':server 001 %s :Welcome\r\n' % messageData
            conexao.enviar(response1)
            response2 = b':server 422 %s :MOTD File is missing\r\n' % messageData
            conexao.enviar(response2)

        
        users[conexao] = messageData
        return
    
    elif messageType == b'PRIVMSG':
        target, content = messageData.split(b' :', 1)

        targetConnections = getConnectionsByChannel(target) if target.startswith(b'#') else getConnectionsByUser(target)

        for targetConnection in targetConnections:
            response = b':%s PRIVMSG %s :%s\r\n' % (users[conexao], target, content)
            print(targetConnection)
            targetConnection.enviar(response)

        return

    else:
        print('? Message type not implemented: "%s"' % messageType)

def usingNick(user):
    return user.lower() in [x.lower() for x in list(users.values())]

def getConnectionsByChannel(channel):
    return []

# it will return an array with 0 or 1 connection
def getConnectionsByUser(user):
    if not usingNick(user):
        return []

    userLowerCase = user.lower()
    connections = list(users.keys())
    usersListLowerCase = [x.lower() for x in list(users.values())]
    userConnection = connections[usersListLowerCase.index(userLowerCase)]
    return [userConnection]

def conexao_aceita(conexao):
    print('> New connection')
    conexao.registrar_recebedor(dados_recebidos)


servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)

print('> Servidor started')

asyncio.get_event_loop().run_forever()
