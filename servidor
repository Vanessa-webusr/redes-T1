#!/usr/bin/env python3
import asyncio
from grader.tcp import Servidor
import re

def validar_nome(nome):
    return re.match(br'^[a-zA-Z][a-zA-Z0-9_-]*$', nome) is not None

def sair(conexao):
    print('> Connection closed')
    conexao.fechar()

def dados_recebidos(conexao, dados):
    if dados == b'':
        return sair(conexao)

    print('! Data received: "%s"' % dados)

    messages = parseMessages(conexao, dados)

    for message in messages:
        if not len(message): continue

        messageType, messageData = message.split(b' ', 1)

        print('> Processing message. Type: "%s" Data: "%s"' % (messageType, messageData))
        handleMessage(conexao, messageType, messageData)

missingData = {}

def parseMessages(conexao, dados):
    global missingData

    # 'linha\r\n'             -> ('linha', '')
    # 'linha1\r\nlinha2\r\n   -> ('linha1', 'linha2', '')
    # 'a 1\r\nlinha 2\r\nli'  -> ('a 1', 'linha 2', 'li')
    # 'lin' ... 'h' ... 'a\r\n'
    messages = dados.split(b'\r\n')

    remoteAddrs = conexao.s.getpeername()

    # inicializa o dicionario para a conexão atual
    if not remoteAddrs in missingData:
        missingData[remoteAddrs] = b''

    # verifica se existe dados residuais da conexão atual
    if not missingData[remoteAddrs] == b'':
        messages[0] = missingData[remoteAddrs] + messages[0]
        missingData[remoteAddrs] = b''

    # verifica se existe dados residuais na última mensagem
    if not messages[-1] == b'':
        missingData[remoteAddrs] = missingData[remoteAddrs] + messages[-1]
        messages[-1] = b''

    # verifica se os dados residuais estão completos
    if missingData[remoteAddrs].endswith(b'\r\n'):
        messages.insert(0, missingData[remoteAddrs])
        missingData[remoteAddrs] = b''

    # deleta do dicionario dados residuais vazios
    if missingData[remoteAddrs] == b'':
        del missingData[remoteAddrs]

    return messages

users = {}

def handleMessage(conexao, messageType, messageData):
    global users

    if messageType == b'PING':
        response = b':server PONG server :%s\r\n' % messageData
        conexao.enviar(response)
        return

    elif messageType == b'NICK':
        if not validar_nome(messageData):
            response = b':server 432 * %s :Erroneous nickname\r\n' % messageData
            conexao.enviar(response)
            return

        remoteAddrs = conexao.s.getpeername()

        # define o apelido_atual
        oldNick = users[remoteAddrs] if remoteAddrs in users else b'*'

        # verifica se o nick já está sendo usado
        if messageData.lower() in [x.lower() for x in list(users.values())]:
            response = b':server 433 %s %s :Nickname is already in use\r\n' % (oldNick, messageData)
            conexao.enviar(response)
            return

        # verifica se o usuário já existe
        if remoteAddrs in users:
            response = b':%s NICK %s\r\n' % (oldNick, messageData)
            conexao.enviar(response)
        else:
            response1 = b':server 001 %s :Welcome\r\n' % messageData
            conexao.enviar(response1)
            response2 = b':server 422 %s :MOTD File is missing\r\n' % messageData
            conexao.enviar(response2)

        users[remoteAddrs] = messageData
        return
    else:
        print('? Message type not implemented: "%s"' % messageType)



def conexao_aceita(conexao):
    print('> New connection')
    conexao.registrar_recebedor(dados_recebidos)


servidor = Servidor(6667)
servidor.registrar_monitor_de_conexoes_aceitas(conexao_aceita)

print('> Servidor started')

asyncio.get_event_loop().run_forever()
